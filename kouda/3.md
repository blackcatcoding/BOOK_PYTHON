# 1.友和敌

```python
# 农民朋友和差役敌人聚集在森林里。
# 命令农民朋友战斗，差役敌人离开！

while True:
    friend = hero.findNearestFriend()
    if friend:
        hero.say("去战斗, " + friend.id + "!")
    # 寻找最近的差役敌人，然后让他们离开。
    enemy = hero.findNearestEnemy()
    if enemy:
        hero.say("快滚开, " + enemy.id)
```



# 2.似曾相识的味道

```python
# 你可以把字符串连起来，或者把数字连接到字符串。
# 一起唱歌，使用字符串连接：
# X potions of health on the wall!
# X potions of health!
# Take Y down, pass it around!
# X-Y potions of health on the wall.

potionsOnTheWall = 10
numToTakeDown = 1
while True:
    hero.say(potionsOnTheWall + " potions of health on the wall!")
    # 唱出下一句：
    hero.say(potionsOnTheWall + " potions of health!")
    # 唱出下一句：
    hero.say("Take " + numToTakeDown + " down, pass it around!")
    potionsOnTheWall -= numToTakeDown
    # 唱出最后一句：
    hero.say(potionsOnTheWall + " potions of health on the wall.")
```



# 3.罪与罚

```python
# 看起来食人魔酋长正在偷你的宝石啊！
# 指挥两门火炮攻击敌人达成目标。

while True:
    enemy = hero.findNearestEnemy()
    if enemy:
        enemyPos = enemy.pos.x + " " + enemy.pos.y
        hero.say("敌人的位置在： " + enemyPos)
        
    # 现在你遇到宝石攻击了
    # 为什么不把宝石也拿走呢？
    # 找到宝石的位置并且
    # 说出它作为火炮的目标。
    item = hero.findNearestItem()
    if item:
        itemPos = item.pos.x + " " + item.pos.y
        hero.say("Item at " + itemPos)
```



# 4.巫师之门

```python
# 去'Laszlo'那里，并获得他的神秘数字。
hero.moveXY(30, 13)
las = hero.findNearestFriend().getSecret()

# 用'Laszlo'的数字加7，得到'Erzsebet'的数字。
# 去'Erzsebet'那里，并说出她的魔法数字。
erz = las + 7
hero.moveXY(17, 26)
hero.say(erz)

# 将'Erzsebet'的数字除以4，得到'Simonyi'的数字。
# 去'Simonyi'那里，并告诉他他的数字。
sim = erz / 4
hero.moveXY(30, 39)
hero.say(sim)

# 将'Simonyi'的数字乘以'Laszlo'的数字，得到'Agata'的数字。
# 去'Agata'那里，并告诉她她的数字。
aga = sim * las
hero.moveXY(43, 26)
hero.say(aga)
```



# 5.巫师出没

```python
# 移动到'Zsofia'的身边，从她那里得到秘密数字。
hero.moveXY(18, 20)
zso = hero.findNearestFriend().getSecret()

# 将'Zsofia'的数字除以 4 来得到'Mihaly'的数字。
# 移动到'Mihaly'并说出他的魔法数字。
mih = zso / 4
hero.moveXY(30, 15)
hero.say(mih)

# 把'Mihaly'的数字除以 5 来得到'Beata'的数字
# 移动到'Beata'并说出她的魔法数字。
bea = mih / 5
hero.moveXY(42, 20)
hero.say(bea)

# 用'Mihaly'的数字减去'Beata'的数字，来得到 Sandor 的数字。
# 移动到'Sandor' 并说出他的魔法数字。
san = mih - bea
hero.moveXY(38, 37)
hero.say(san)
```



# 6.巫师天际层

```python
# 移动到'Eszter'并从她那里得到神秘数字。
hero.moveXY(16, 32)
esz = hero.findNearestFriend().getSecret()

# 乘以3，减去2，得到'Tamas'的数字。
# 记住使用括号来确保计算顺序正确。
# 移到'Tamas'并说出他的魔法数字。
tam = (esz * 3) - 2
hero.moveXY(24, 28)
hero.say(tam)

# 然后继续 减去1然后乘4得到'Zsofi'的数字
# 移到'Zsofi'并说出她的魔法数字。
zso = (tam - 1) * 4
hero.moveXY(32, 24)
hero.say(zso)

# 先将'Tamas'和'Zsofi'的数字相加，然后除以2得到'Istvan'的数字。
# 移到'Istvan'并说出他的魔法数字。
ist = (tam + zso) / 2
hero.moveXY(40, 20)
hero.say(ist)

# 先将'Tamas'和'Zsofi'的数字相加，然后用'Zsofi'的数字减去'Istvan'的数字，再将两个结果相乘得到'Csilla'的数字。
# 移动到'Csilla'并说出她的魔法数字。
csi = (tam + zso) * (zso - ist)
hero.moveXY(48, 16)
hero.say(csi)
```



# 7.币屑

```python
# 跟随硬币的轨迹来到红色 X 标记的出口。

while True:
    # 这能找到最近的物品。
    item = hero.findNearestItem()
    if item:
        # 这将物品的pos，也就是坐标，存储在变量中。
        itemPosition = item.pos
        # 将物品的 X 和 Y 坐标存入变量。
        itemX = itemPosition.x
        itemY = itemPosition.y
        # 现在，使用moveXY移动到itemX和itemY：
        hero.moveXY(itemX, itemY)

```



# 8.白兔

```python
# 跟随发光石通过陷阱。

while True:
    item = hero.findNearestItem()
    if item:
        # 使用 item.pos 将物品位置保存到一个新的变量中：
        position = item.pos
        # 使用 pos.x 和 pos.y 保存X和Y坐标：
        x = position.x
        y = position.y
        # 使用 moveXY() 和 变量X、Y移动至坐标：
        hero.moveXY(x, y)
```



# 9.伪装者

```python
# 食人魔伪装成了硬币或者宝石！

while True:
    enemy = hero.findNearestEnemy()
    # 如果你看见了敌人，攻击它：
    if enemy:
        hero.attack(enemy)
    item = hero.findNearestItem()
    # 如果你看见硬币或者宝石，移动到它的X和Y坐标：
    if item:
        pos = item.pos
        hero.moveXY(pos.x, pos.y)

```



# 10.边地投弹

```python
# pos属性是一个具有x和y属性的对象。
# pos.x是代表地图上水平位置的数字
# pos.y是代表地图上竖直位置的数字

while True:
    enemy = hero.findNearestEnemy()
    if enemy:
        x = enemy.pos.x
        y = enemy.pos.y
        # 说出x和y位置，用逗号隔开
        hero.say(x + "," + y)
    else:
        hero.say("停止" + " " + "开火！")

```



# 11.叫阵

```python
# 只有当 if 条件为真的时候，if 语句下面的命令才会执行。
# 在条件中，==表示"等于"。
if 2 + 2 == 4:
    hero.say("嘿！")
if 2 + 2 == 5:
    hero.say("是的，你！")

# 改变这里的条件，让英雄说 来打我啊！
if 3 + 3 == 6:  # ∆ 让这个成立。
    hero.say("来打我啊！")

if 20 == 20:  # ∆ 让这个成立。
    # 再添加一句嘲讽来引诱食人魔，来点有创意的！
    hero.say("有种你过来啊！")
```



# 12.濒危树瘤之战

```python
# 只攻击"thrower"和"munchkin"两种类型的敌人。
# 别攻击"burl"，遇到"ogre"快跑！
while True:
    enemy = hero.findNearestEnemy()
    
    # 记住：别攻击"burl"类型！
    if enemy.type == "burl":
        hero.say("I'm not attacking that Burl!")
    
    # "type"属性告诉你对象是什么类型。
    if enemy.type == "munchkin":
        hero.attack(enemy)
    
    # 使用"if"来来攻击"thrower"。
    if enemy.type == "thrower":
        hero.attack(enemy)
        
    # 如果是"ogre"，使用moveXY逃跑去村口！
    if enemy.type == "ogre":
        hero.moveXY(41, 47)
```



# 13.嘲弄

```python
# 攻击矮人，呼叫斗士，忽略树精。

# 这个函数定义了英雄对敌人采取的行动。
def dealEnemy(enemy):
    # 如果敌人的类型是"munchkin"：
    if enemy.type == "munchkin":
        # 那么就攻击它：
        hero.attack(enemy)
    # 如果敌人的类型是"brawler"：
    if enemy.type == "brawler":
        # 那么就说些什么来呼叫斗士：
        hero.say("Hey you!")

while True:
    enemy = hero.findNearestEnemy()
    if enemy:
        dealEnemy(enemy)
    else:
        hero.moveXY(30, 34)

```



# 14.树精森林

```python
# 不要攻击树精！
# 函数可以返回一个值。
# 当函数被调用时，它将等于函数返回的值。

def shouldAttack(target):
    # return False 如果没有`target`
    if not target:
        return False
    # return False 如果target.type == "burl"
    if target.type == "burl":
        return False
    # 否则 return True
    return True

while True:
    enemy = hero.findNearestEnemy()
    # 在这里，我们使用shouldAttack()来决定是否应该进行攻击！
    # heroShouldAttack将被赋值为shouldAttack()返回的值！
    heroShouldAttack = shouldAttack(enemy)
    if heroShouldAttack:
        hero.attack(enemy)

```



# 15.盲距

```python
# 告诉巫师，来袭食人魔的距离。

# 这个函数寻找最近的敌人，并返回距离。
# 如果没有敌人，则该函数返回0。
def nearestEnemyDistance():
    enemy = hero.findNearestEnemy()
    result = 0
    if enemy:
        result = hero.distanceTo(enemy)
    return result

while True:
    # 调用nearestEnemyDistance()并
    # 将结果保存在变量enemyDistance中。
    enemyDistance = nearestEnemyDistance()
    # 如果enemyDistance大于0：
    if enemyDistance > 0:
        # 说出enemyDistance变量的值。
        hero.say(enemyDistance)

```



# 16.固定打击

```python
# 你掉进陷阱里了！别动！你会受伤的！

# 这个函数检查敌人是否在攻击范围内。
def inAttackRange(enemy):
    distance = hero.distanceTo(enemy)
    # 几乎所有剑的攻击范围都是3。
    if distance <= 3:
        return True
    else:
        return False

# 只有在触手可及的范围内才能攻击食人魔。
while True:
    # 找到最近的敌人，并将其储存在一个变量中。
    nearestEnemy = hero.findNearestEnemy()
    # 调用inAttackRange(enemy)，将enemy作为参数
    # 把结果保存于canAttack变量中
    canAttack = inAttackRange(nearestEnemy)
    # 如果存储在canAttack中的结果是 True, 则发起攻击！
    if canAttack:
        hero.attack(nearestEnemy)

```



# 17.金币猎手

```python
# 为了让训练更有趣，Senick给你下了毒。
# 当你不移动时，毒是无害的。

# 该函数会检查硬币的距离是否小于20米。
def isCoinClose(coin):
    # 确定与`coin`之间的距离。
    distance = hero.distanceTo(coin)
    # 如果距离小于20：
    if distance < 20:
        # 返回 True
        return True
    # 否则：
    else:
        # 返回 False
        return False

while True:
    item = hero.findNearestItem()
    if item:
        # 如果isCoinClose(item)返回true：
        if isCoinClose(item):
            hero.moveXY(item.pos.x, item.pos.y)

```



# 18.返回AGRIPPA

```python
def enemyInRange(enemy):
    # 如果敌人的距离少于5米，则返回True值。
    distance = hero.distanceTo(enemy)
    if distance < 5:
        return True
    else:
        return False

def cleaveOrAttack(enemy):
    if hero.isReady('cleave'):
        hero.cleave(enemy)
    else:
        hero.attack(enemy)

while True:
    enemy = hero.findNearestEnemy()
    if enemy:
        # 调用 enemyInRange 来检查敌人的距离。
        if enemyInRange(enemy):
            cleaveOrAttack(enemy)

```



# 19.金属探测器

```python
# 大炮以硬币作为目标。
# 你就像是炮兵的测距仪。

# 编写函数。
def coinDistance():
    # 找到最近的硬币，
    coin = hero.findNearestItem()
    # 如果有一枚硬币，返回到它的距离。
    if coin:
        distance = hero.distanceTo(coin)
        return distance
    # 否则，返回0（零）。
    else:
        return 0

while True:
    distance = coinDistance()
    if distance > 0:
        # 说`distance`。
        hero.say(distance)
        
```



# 20.穿越

```python
# 不要侮辱这个和平食人魔部落

while True:
    item = hero.findNearestItem()
    if item:
        # 如果item.type不等于 "gem"
        if item.type != "gem":
            # 然后跟随你的宠物。
            hero.moveXY(pet.pos.x, pet.pos.y)
        # 否则:
        else:
            # 移动到宝石的坐标。
            hero.moveXY(item.pos.x, item.pos.y)

```



# 21.有用的对手

```python
# 这片满是硬币的地方暗藏了致命的毒药。
# 食人魔正在进攻，而差役尝试偷你的硬币！

while True:
    enemy = hero.findNearestEnemy()
    if enemy:
        # 只在敌人类型不是 "peon" 的时候攻击。
        if enemy.type != "peon":
            hero.attack(enemy)
    item = hero.findNearestItem()
    if item:
        # 只在物品的类型不是 "poison" 的时候捡起。
        if item.type != "poison":
            hero.moveXY(item.pos.x, item.pos.y)

```



# 22.奇境

```python
# 你需要收集几种物品。
# 不过，树精想要宝石！
# 拿走所有出现的物品，除了宝石。

while True:
    # 找到最近的物品。
    item = hero.findNearestItem()
    # 如果那儿有一个物品：
    if item:
        # 如果item.type不等于"gem"：
        if item.type != "gem":
            # 移动到物品的位置。
            hero.moveXY(item.pos.x, item.pos.y)

```



# 23.被诅咒的梦境

```python
# 自从我们上次访问梦境就已经被改变了。
# 食人魔诅咒了它，我们应该击败它们。
# 树精仍然在收集宝石，所以别碰它们。
# 并且不要攻击树精。

while True:
    # 找到最近的物品。
    # 只有在它（如果它存在）的类型不是"gem"才收集它
    item = hero.findNearestItem()
    if item:
        if item.type != 'gem':
            hero.moveXY(item.pos.x, item.pos.y)
    # 找到最近的敌人。
    # 如果它存在并且类型不是"burl"，则攻击他。
    enemy = hero.findNearestEnemy()
    if enemy:
        if enemy.type != 'burl':
            hero.attack(enemy)

```



# 24.宝石或者死亡

```python
# if语句只在相应条件成立时才会运行。
# 修复所有if语句的条件表达式来通过本关。

# ==的意思是"等于"。
if 1 + 1 + 1 == 4: # ∆ 让该条件不成立。
    hero.moveXY(5, 15)  # 移动到第一个雷区的位置。

if 2 + 2 == 4: # ∆ 让该条件成立。
	hero.moveXY(15, 40)  # 移动到第一枚宝石的位置。

# !=的意思是"不等于"。
if 2 + 2 != 5: # ∆ 让该条件成立。
	hero.moveXY(25, 15)  # 移动到第二枚宝石的位置

# <的意思是"小于"。
if 2 + 2 < 5: # ∆ 让该条件成立。
    enemy = hero.findNearestEnemy()
    hero.attack(enemy)

if 2 < 1: # ∆ 让该条件不成立。
	hero.moveXY(40, 55)

if not True: # ∆ 让该条件不成立。
	hero.moveXY(50, 10)

if not False: # ∆ 让该条件成立。
	hero.moveXY(55, 25)

```



# 25.BURL和布尔

```python
# 布尔值要么是真 True 要么是假 False
# ==符号表示 "是否等于？"
# 因此， A == B 是在问："A是否等于B？"
# 答案是一个布尔值！
# 如果没懂，请点"Hints"按钮来获得提示！

# 问题: 2 == 3 
# 说出正确的答案:
hero.say(False)

# 问题: 3 == 3
# 回答 True 或者 False  2:
hero.say(True)

# 问题: "Three" == 3
# 回答 True 或者 False  3:
hero.say(False)

# 问题: "Three" == "Three"
# 回答 True 或者 False  4:
hero.say(True)

# 问题: 1 + 2 == 3
# 回答 True 或者 False  5:
hero.say(True)

```



# 26.盐碱地

```python
# 食人魔正在攻击附近的一个定居点！
# 小心，食人魔在地上放了毒药。
# 收集硬币并击败食人魔，但要避免树精和毒药！

while True:
    enemy = hero.findNearestEnemy()
    if enemy.type == "munchkin" or enemy.type == "thrower":
        hero.attack(enemy)
    item = hero.findNearestItem()
    # 检查物品类型，确保英雄不会捡起毒药！
    # 如果物品的类型是"gem"或"coin"：
    if item.type == "coin" or item.type == "gem":
        # 那么移动并将其捡起：
        hero.moveXY(item.pos.x, item.pos.y)
        
```



# 27.流星雨

```python
# 只在硬币距离小于20米时才捡起硬币。
# 捡起所有的宝石。

while True:
    item = hero.findNearestItem()
    distance = hero.distanceTo(item)
    # 如果物品的类型是"gem"
    # 或到物品的距离小于20米：
    if item.type == "gem" or distance < 20:
        # 移动到物品的位置。
        hero.moveXY(item.pos.x, item.pos.y)

```



# 28.森林影子

```python
# 大食人魔在森林里看不到你。
# 只攻击森林里的小食人魔。
# 只收集硬币和宝石。
# 不要离开森林，不要吃喝任何东西。

while True:
    # 找到最近的敌人。
    # 只有当类型是"thrower"或"munchkin"时才攻击。
    enemy = hero.findNearestEnemy()
    if enemy.type == "thrower" or enemy.type == "munchkin":
        hero.attack(enemy)
    # 找到最近的物品。
    # 只有当类型是"gem"或"coin"时才收集。
    item = hero.findNearestItem()
    if item.type == "gem" or item.type == "coin":
        hero.moveXY(item.pos.x, item.pos.y)

```



# 29.春雷

```python
# 某些硬币和宝石会引来雷电。
# 英雄应该只收集银币和蓝宝石。

while True:
    item = hero.findNearestItem()
    # 一枚银币的价值是2。
    # 如果item.type等于"coin"，则收集
    # 且item.value等于2。
    if item.type == "coin" and item.value == 2:
        hero.moveXY(item.pos.x, item.pos.y)
    # 一枚蓝宝石的价值是10。
    # 如果item.type等于"gem"，则收集
    # 且item.value等于10。
    if item.type == "gem" and item.value == 10:
        hero.moveXY(item.pos.x, item.pos.y)

```



# 30.传送套索

```python
# 我们的巫师把食人魔从它们的营地传送过来。
# 它们出现的时间很短，且处于晕厥状态。
# 只攻击弱小和近邻的食人魔。

while True:
    enemy = hero.findNearestEnemy()
    if enemy:
        distance = hero.distanceTo(enemy)
        # 如果enemy.type是"munchkin"
        # 且距离小于20米。
        if enemy.type == "munchkin" and distance < 20:
            # 则攻击它。
            hero.attack(enemy)
```



# 31.狩猎斗士

```python
# 不要担心小型和中型食人魔。
# 你的射击目标类型是"brawler"。
# 当"brawler"的距离小于50米时，用大炮射击。

while True:
    # 找到最近的敌人，并确定与它的距离。 
    enemy = hero.findNearestEnemy()
    distance = hero.distanceTo(enemy)
    # 如果敌人的类型是"brawler"
    # 且距离它不到50米，
    # 那就说"Fire!"，命令大炮开火。
    if enemy.type == "brawler" and distance < 50:
        hero.say("Fire!")

```



# 32.平常的一天

```python
# 打败食人魔矮人，收集硬币。一切都那么平常。
# 使用与(AND)，只需一条语句就能检查存在性和类型。

while True:
    enemy = hero.findNearestEnemy()
    # 使用与(AND)以后，我们只会在敌人存在时检查类型。
    if enemy and enemy.type == "munchkin":
        hero.attack(enemy);
    # 寻找最近的物品
    item = hero.findNearestItem()
    # 如果存在且类型为"coin"，则收集该物品。
    if item and item.type == "coin":
        hero.moveXY(item.pos.x, item.pos.y)

```



# 33.逻辑之路

```python
# 从巫师那得到两个秘密的true/false值。
# 查看提示，可以了解如何编写逻辑表达式。
hero.moveXY(14, 24)
secretA = hero.findNearestFriend().getSecretA()
secretB = hero.findNearestFriend().getSecretB()

# 如果 secretA 和 secretB 都为真，走上面的路；否则，走下面。
secretC = secretA and secretB
if secretC:
    hero.moveXY(20, 33)
else:
    hero.moveXY(20, 15)
hero.moveXY(26, 24)

# 如果 secretA 或 secretB 有一个为真，走上面；否则，走下面。
secretD = secretA or secretB
if secretD:
    hero.moveXY(32, 33)
else:
    hero.moveXY(32, 15)
hero.moveXY(38, 24)

# 如果 secretB 非真，走上面；否则，走下面。
secretE = not secretB
if secretE:
    hero.moveXY(44, 33)
else:
    hero.moveXY(44, 15)
hero.moveXY(50, 24)

```



# 34.逻辑之圈

```python
# 移动到巫师旁，获得他的秘密值。
hero.moveXY(20, 24)
secretA = hero.findNearestFriend().getSecretA()
secretB = hero.findNearestFriend().getSecretB()
secretC = hero.findNearestFriend().getSecretC()

# 如果所有三个值都为真，则走上面。
# 否则，往下走。保存第四个值。
secretD = secretA and secretB and secretC
if secretD:
    hero.moveXY(30, 33)
else:
    hero.moveXY(30, 15)

# 如果三个值中的任何一个为真，则走左边。
# 否则，向右走。保存第五个值。
secretE = secretA or secretB or secretC
if secretE:
    hero.moveXY(20, 24)
else:
    hero.moveXY(40, 24)

# 否则，走下面。
secretF = secretA and secretB and secretC and secretD and secretE
if secretF:
    hero.moveXY(30, 33)
else:
    hero.moveXY(30, 15)

```



# 35.逻辑结论

```python
# 移动到 'Eszter' 身边，从她那得到三个秘密值。
hero.moveXY(24, 16)
secretA = hero.findNearestFriend().getSecretA()
secretB = hero.findNearestFriend().getSecretB()
secretC = hero.findNearestFriend().getSecretC()

# 当 A AND B为真，或者 C为真，对'Tamas'说"TRUE"。不成立则说"FALSE"
# 记得用括号让逻辑顺序正确。
tam = (secretA and secretB) or secretC
hero.moveXY(19, 26)
hero.say(tam)

# 当 A OR B为真，且 C为真，对'Zsofi'说"TRUE"。不成立则说"FALSE"
zso = (secretA or secretB) and secretC
hero.moveXY(26, 36)
hero.say(zso)

# 当 A OR C为真，且 B OR C为真，对'Istvan'说"TRUE"。不成立则说"FALSE"
ist = (secretA or secretC) and (secretB or secretC)
hero.moveXY(37, 34)
hero.say(ist)

# 当 A AND B为真，或者 B为真且C为非真，对'Csilla'说"TRUE"。不成立则说"FALSE"
csi = (secretA and secretB) or (secretB and (not secretC))
hero.moveXY(40, 22)
hero.say(csi)

```



# 36.强壮的沙牦牛

```python
# 当牦牛靠近时，向右移动10米来躲避。
# 躲避4头牦牛来通过此关。

while True:
    # 获取英雄当前位置的x和y坐标。
    x = hero.pos.x
    y = hero.pos.y
    
    # 找到最近的耗牛。
    yak = hero.findNearestEnemy()
    
    # 如果到牦牛的距离小于10：
    if hero.distanceTo(yak) < 10:
        # 向右移动，在英雄位置的x坐标值基础上加10。
        x += 10
        # Use moveXY to move!
        hero.moveXY(x, y)
```



# 37.绿洲

```python
# 向右移动以到达绿洲，
# 向左移动以避免附近的牦牛。
while True:
    x = hero.pos.x
    y = hero.pos.y
    enemy = hero.findNearestEnemy()
    if enemy and hero.distanceTo(enemy) < 10:
        #  用x减10来向左移动。
        x -= 10
        # 使用moveXY移动到新的x,y位置。
        hero.moveXY(x, y)
    else:
        # 用x加10来向右移动。
        x += 10
        # 使用moveXY移动到新的x,y位置。
        hero.moveXY(x, y)
```



# 38.SARVEN路

```python
# 朝绿洲前进。小心新的敌人：食人魔侦察兵！
# 通过增加当前的x和y坐标值来向右上移动。

while True:
    # 如果有敌人，则攻击。
    enemy = hero.findNearestEnemy()
    if enemy:
        hero.attack(enemy)
    # 否则，继续向右上移动。
    else:
        xPos = hero.pos.x
        yPos = hero.pos.y
        hero.moveXY(xPos + 5, yPos + 5)
```



# 39.SARVEN间隙

```python
# 每次向下移动10米，朝绿洲移动。
# 在每个食人魔左边20米的位置建造围栏。

while True:
    enemy = hero.findNearestEnemy()
    if enemy:
        # 在敌人左边20个单位处使用buildXY建造一段"fence"
        x = enemy.pos.x - 20
        y = enemy.pos.y
        hero.buildXY("fence", x, y)
    else:
        # 向下使用moveXY移动10米。
        x = hero.pos.x
        y = hero.pos.y - 10
        hero.moveXY(x, y)
```



# 40.十字路口

```python
# 使用 "fire-trap"打败食人魔。

while True:
    enemy = hero.findNearestEnemy()
    if enemy:
        if enemy.pos.x < hero.pos.x:
            # 在左侧X处使用buildXY建造一个"fire-trap"。
            hero.buildXY("fire-trap", 25, 34)
        elif enemy.pos.x > hero.pos.x:
            # 在右侧X处使用buildXY建造一个"fire-trap"。
            hero.buildXY("fire-trap", 55, 34)
        elif enemy.pos.y < hero.pos.y:
            # 在下面的X处使用buildXY建造一个"fire-trap"。
            hero.buildXY("fire-trap", 40, 19)
        elif enemy.pos.y > hero.pos.y:
            # 在上面的X处使用buildXY建造一个"fire-trap"。
            hero.buildXY("fire-trap", 40, 49)
    hero.moveXY(40, 34)
```



# 41.截断

```python
# 站在农民和塔之间。

while True:
    enemy = hero.findNearestEnemy()
    friend = hero.findNearestFriend()
    # 通过将friend.pos.x和enemy.pos.x相加来计算x
    # 然后除以2。
    # 如需更多帮助，请查看指南！
    x = (friend.pos.x + enemy.pos.x) / 2
    # 现在对y做同样的事情
    y = (friend.pos.y + enemy.pos.y) / 2
    # 移动到计算得到的X和Y坐标。
    hero.moveXY(x, y)

```



# 42.雷蹄

```python
# 向右朝绿洲移动。
# 看到牦牛时，在上方或是下方建造一段"fence"

while True:
    yak = hero.findNearestEnemy()
    if yak:
        # 如果yak.pos.y大于hero.pos.y
        if yak.pos.y > hero.pos.y:
            # 使用buildXY在牦牛下方10米处建造一段"fence"
            hero.buildXY("fence", yak.pos.x, yak.pos.y - 10)
        # else:
        else:
            # 使用buildXY在牦牛上方10米处建造一段"fence"
            hero.buildXY("fence", yak.pos.x, yak.pos.y + 10)
    else:
        # 使用moveXY向右朝绿洲移动10米。
        hero.moveXY(hero.pos.x + 10, hero.pos.y)
```



# 43.KITHGRAD附魔师

```python
# 定义你自己的简单移动函数。
# 定义moveRight
# 注意：每个函数都应该让英雄移动12米！
def moveRight():
    x = hero.pos.x + 12
    y = hero.pos.y
    hero.moveXY(x, y)

# 定义moveUp
def moveUp():
    x = hero.pos.x
    y = hero.pos.y + 12
    hero.moveXY(x, y)

# 定义moveDown
def moveDown():
    x = hero.pos.x
    y = hero.pos.y - 12
    hero.moveXY(x, y)

# 现在，使用这些函数！
moveRight()
moveDown()
moveUp()
moveUp()
moveRight()

```



# 44.扫雷

```python
# 带领农民和医生穿越雷区。

while True:
    coin = hero.findNearestItem()
    healingThreshold = hero.maxHealth / 2
    # 检查你是否身受重伤。
    if hero.health < healingThreshold:
        # 向左移动10米。
        x = hero.pos.x
        y = hero.pos.y
        hero.moveXY(x - 10, y)
        # 请求治疗。
        hero.say("Can I get a heal?")
    # 否则，移动到下一枚硬币。
    elif coin:
        hero.moveXY(coin.pos.x, coin.pos.y)
```



# 45.'KILLDEAR'操作

```python
# 诱使食人魔陷入陷阱。 这些食人魔很谨慎。
# 只有英雄受伤时，他们才会追击。

# 该函数检查英雄的生命值
# 并返回一个布尔值。
def shouldRun():
    if hero.health < hero.maxHealth / 2:
        return True
    else:
        return False

while True:
    # 只有当shouldRun（）返回True时才移动到X.  True
    if shouldRun():
        hero.moveXY(75, 37)
    # 否则，攻击！
    else:
        enemy = hero.findNearestEnemy()
        if enemy:
            hero.attack(enemy)
```



# 46.医疗护理

```python
# 当你的生命值少于一半时，请求治疗师的帮助。

while True:
    currentHealth = hero.health
    healingThreshold = hero.maxHealth / 2
    # 如果你当前的生命值低于界限值，
    # 转移到治疗点并说， "heal me".
    # 否则的话，攻击。你需要奋战！
    if hero.health < healingThreshold:
        hero.moveXY(65, 46)
        hero.say("Heal please!")
    else:
        enemy = hero.findNearestEnemy()
        if enemy:
            hero.attack(enemy)
```



# 47.守时

```python
# 使用你的新技能来选择你要做什么： hero.time

while True:
    # 如果是前十秒，攻击。
    if hero.time < 10:
        enemy = hero.findNearestEnemy()
        if enemy:
            hero.attack(enemy)
    # 否则，如果是前35秒，收集硬币。
    elif hero.time < 35:
        coin = hero.findNearestItem()
        if coin:
            hero.moveXY(coin.pos.x, coin.pos.y)
    # 35秒后，再次发起攻击！
    else:
        enemy = hero.findNearestEnemy()
        if enemy:
            hero.attack(enemy)
```



# 48.沙漠十字

```python
# 弄清食人魔来自哪个方向。

while True:
    enemy = hero.findNearestEnemy()
    if enemy:
        # 左边：enemy.pos.x小于hero.pos.x
        isLeft = hero.pos.x  > enemy.pos.x
        # 上方：enemy.pos.y大于hero.pos.y
        isAbove = hero.pos.y < enemy.pos.y
        # 右边：enemy.pos.x大于hero.pos.x
        isRight = hero.pos.x  < enemy.pos.x
        # 下方：enemy.pos.y小于hero.pos.y
        isBelow = hero.pos.y > enemy.pos.y
        # 如果敌人在上方 (isAbove) 且 在左边 (isLeft)：
        # 使用buildXY()在X标记处建造一个"fire-trap"。
        if isLeft and isAbove:
            hero.buildXY("fire-trap", 20, 51)
        # 如果敌人在上方 (isAbove) 且 在右边 (isRight)：
        # 使用buildXY()在X标记处建造一个"fire-trap"。
        if isRight and isAbove:
            hero.buildXY("fire-trap", 60, 51)
        # 如果敌人在下方 (isBelow) 且 在左边 (isLeft)：
        # 使用buildXY()在X标记处建造一个"fire-trap"。
        if isLeft and isBelow:
            hero.buildXY("fire-trap", 20, 17)
        # 如果敌人在下方 (isBelow) 且 在右边 (isRight)：
        # 使用buildXY()在X标记处建造一个"fire-trap"。
        if isRight and isBelow:
            hero.buildXY("fire-trap", 60, 17)
        hero.moveXY(40, 34)
    else:
        hero.moveXY(40, 34)

```



# 49.囤积黄金

```python
# 收集25金，然后告诉 Naria 总数。
# 当totalGold >= 25，使用 break 来停止收集。

totalGold = 0
while True:
    coin = hero.findNearestItem()
    if coin:
        # 捡起硬币。
        hero.moveXY(coin.pos.x, coin.pos.y)
        # 将硬币的价值加到totalGold。
        # 使用以下方法得到它的价值：:  coin.value
        totalGold += coin.value
    
    if totalGold >= 25:
        # 这会中断跳出循环并执行循环下面的语句。
        # 循环结束后，运行循环后的代码。
        break

# 完成收集黄金！
hero.moveXY(58, 33)
# 去告诉 Naria 你收集了多少黄金。
hero.say(totalGold)
```



# 50.诱饵练习

```python
# 我们在测试一个新的建造类型：诱饵(decoy)。
# 建造4个诱饵，然后汇报总数给Naria。

decoysBuilt = 0
while True:
    coin = hero.findNearestItem()
    
    if coin:
        # 收集硬币！
        hero.moveXY(coin.pos.x, coin.pos.y)
    # 每个诱饵消费25金。
    # 如果hero.gold大于或等于25：
    if hero.gold >= 25:
        # 用buildXY建造一个"decoy"
        hero.buildXY("decoy", hero.pos.x, hero.pos.y)
        # 为decoysBuilt计数值加1。
        decoysBuilt += 1
    if decoysBuilt == 4:
        # 建造了4个诱饵后跳出循环。
        break
    
hero.say("Done building decoys!")
hero.moveXY(14, 36)
# 说出你建造了多少诱饵。
hero.say(decoysBuilt)
```



# 51.炼金术传承

```python
# 和食人魔矮人抢Omarn Brewstone提取出的水！
# 使用`continue`语句避开毒药。
while True:
    enemy = hero.findNearestEnemy()
    item = hero.findNearestItem()
    
    # 如果没有敌人，使用continue跳出此轮循环继续运行。
    if not enemy:
        continue
    
    # 如果没有物品，要一瓶药水，然后continue。
    if not item:
        hero.say("给我点喝的！")
        continue
    
    # 如果item.type是"poison"，使用continue跳出此轮循环继续运行。
    if item.type is "poison":
        continue
    # 此时，药水一定是一瓶水
    # 使用moveXY移到药水，然后回到起点！
    hero.moveXY(44, 35)
    hero.moveXY(34, 47)
```



# 52.快速赛跑

```python
# 使用事件处理器，这样宠物和英雄都会跑起来！

def petMove(event):
    pet.moveXY(50, 21)

# 使用pet.on("spawn", petMove)替换petMove()
# 这样你的英雄和宠物就会同时跑起来。
pet.on("spawn", petMove)
hero.moveXY(50, 12)

```



# 53.沙漠蘑菇

```python
# 收集9个蘑菇。

# 这个函数让宠物给你取回药水。
def onSpawn(event):
    while True:
        # 宠物可以根据类型找到最近的物品。
        potion = pet.findNearestByType("potion")
        # 如果存在药水则让宠物取回：
        if potion:
            pet.fetch(potion)

pet.on("spawn", onSpawn)

# 蘑菇有毒，不要太快收集。
while True:
    someItem = hero.findNearestItem()
    if someItem and hero.health > hero.maxHealth / 3:
        # 收集someItem：
        hero.moveXY(someItem.pos.x, someItem.pos.y)

```



# 54.蘑菇之声

```python
# 打败骷髅并打开宝箱。

def onSpawn (event):
    # 宠物要找到生命药水（类型是 "potion"）：
    potion = pet.findNearestByType("potion")
    # 并将它取回：
    pet.fetch(potion)
    # 宠物要找到金钥匙（类型是"gold-key"）：
    goldKey = pet.findNearestByType("gold-key")
    # 并将它取回：
    pet.fetch(goldKey)

# 宠物可以发现的不仅仅是物品：
skeleton = pet.findNearestByType("skeleton")
pet.on("spawn", onSpawn)

while True:
    if skeleton.health > 0:
        hero.attack(skeleton)
    else:
        hero.moveXY(31, 38)

```



# 55.钥匙陷阱

```python
# 获得三把钥匙并释放圣骑士。

def onSpawn(event):
    # 宠物需要找到并拿回3把钥匙。
    # 你需要后续类型的物品：
    # "bronze-key"、"silver-key"和"gold-key"。
    pet.fetch(pet.findNearestByType("bronze-key"))
    pet.fetch(pet.findNearestByType("silver-key"))
    pet.fetch(pet.findNearestByType("gold-key"))

pet.on("spawn", onSpawn)

while True:
    enemy = hero.findNearestEnemy()
    if enemy and enemy.team == "ogres":
        hero.attack(enemy)
    if hero.health < 300:
        # 你也可以在主线程中使用宠物。
        potion = pet.findNearestByType("potion")
        if potion:
            hero.moveXY(potion.pos.x, potion.pos.y)

```



# 56.命令链

```python
# 只有你的宠物可以唤醒巫师。

def onHear(event):
    # "hear"事件设置event.speaker属性。
    # 检查宠物是否听到了英雄的话：
    if event.speaker == hero:
        pet.say("WOOF")

# 为"hear"事件指派事件处理器。
pet.on("hear", onHear)

while True:
    enemy = hero.findNearestEnemy()
    # 如果有敌人：
    if enemy:
        # 使用hero.say()提醒你的宠物
        hero.say("Ogres!")
        # 移动到营地内的X处。
        hero.moveXY(30, 33)
        # 然后返回营地外的X处。
        hero.moveXY(30, 15)

```



# 57.宠物工程师

```python
# 根据需要将宠物移到左或右按钮。

def onHear(event):
    # 找到门卫
    archer = pet.findNearestByType("archer")
    soldier = pet.findNearestByType("soldier")
    # 如果"event.speaker"参数是 `archer`：
    if event.speaker == archer:
        # 移动到左边的按钮。
        pet.moveXY(32, 30)
    # 如果"event.speaker"参数是`soldier`：
    elif event.speaker == soldier:
        # 移动到右边的按钮。
        pet.moveXY(48, 30)

pet.on("hear", onHear)

# 您不必更改下面的代码。
# 你的英雄应该保护右下角的通道。
while True:
    enemy = hero.findNearestEnemy()
    if enemy:
        hero.attack(enemy)

```



# 58.宠物翻译家

```python
# 你的宠物应该翻译命令。
 
def onHear(event):
    # 宠物听到的消息在event.message中
    message = event.message
    # 如果消息是 "North"：
    if message == "North":
        # 宠物说 "Htron"。
        pet.say("Htron")
    # 如果消息是 "South"：
    if message == "South":
        # 宠物说 "Htuos"。
        pet.say("Htuos")
    # 如果消息是 "East"：
    if message == "East":
        # 宠物说 "Tsae"。
        pet.say("Tsae")

# 分配事件处理程序。
pet.on("hear", onHear)

while True:
    enemy = hero.findNearestEnemy()
    # 不要攻击Brawlers。
    if enemy and enemy.type != "brawler":
        hero.attack(enemy)
    else:
        hero.moveXY(26, 26)
```



# 59.宠物副官

```python
# 你的宠物可以帮助你活下来，直到你可以逃脱。

def onHear(event):
    # event.message包含所听到的文本。
    # 如果有人说 "Fire"
    if event.message == "Fire":
        # 用pet.moveXY（）移动到底部的X标记
        pet.moveXY(64, 16)
        # 使用pet.say()说点什么
        pet.say("MEAW")
    # 如果有人说 "Heal"
    elif event.message == "Heal":
        # 用pet.moveXY（）移动到顶部的X标记
        pet.moveXY(64, 52)
        # 使用pet.say()说点什么
        pet.say("MEAW")

pet.on("hear", onHear)

# 您不必更改下面的代码。
while True:
    enemy = hero.findNearestEnemy()
    if enemy:
        # 如果敌人太强大。
        if enemy.type == "brawler":
            hero.say("Fire")
        else:
            hero.attack(enemy)
    else:
        # 如果你的英雄需要治疗。
        if hero.health < hero.maxHealth / 2:
            hero.say("Heal")

```



# 60.炼金术

```python
# 等着炼金师的命令去拿药水。

# 宠物事件的事件处理程序 "hear"。
def onHear(event):
    # 找到最近的药水。
    potion = pet.findNearestByType("potion")
    message = event.message
    # 如果事件的消息是 "Fetch"
    if message == "Fetch":
        # 让宠物拿取药水。
        pet.fetch(potion)
    # 其他（对于任何其他消息）：
    else:
        # 用pet.moveXY 让宠物回到红色标记。
        pet.moveXY(54, 34)

pet.on("hear", onHear)

# 您不必更改下面的代码。
while True:
    enemy = hero.findNearest(hero.findEnemies())
    if enemy:
        hero.attack(enemy)
    else:
        hero.moveXY(40, 34)

```



# 61.危险钥匙

```python
# 听圣骑士的，取回正确的钥匙。

def onHear(event):
    # 宠物可以找到圣骑士和钥匙。
    paladinUnit = pet.findNearestByType("paladin")
    goldKey = pet.findNearestByType("gold-key")
    silverKey = pet.findNearestByType("silver-key")
    bronzeKey = pet.findNearestByType("bronze-key")
    # 如果event.speaker是paladinUnit：
    if event.speaker == paladinUnit:
        # 如果event.message是"Gold"：
        if event.message == "Gold":
            # 宠物需要取金钥匙。
            pet.fetch(goldKey)
        # 如果event.message是 "Silver"：
        elif event.message == "Silver":
            # 宠物需要取银钥匙。
            pet.fetch(silverKey)
        # 如果event.message是"Bronze"：
        elif event.message == "Bronze":
            # 宠物需要取青铜钥匙。
            pet.fetch(bronzeKey)

pet.on("hear", onHear)

```



# 62.奥林匹克比赛

```python
# 宠物必须赢得比赛。
# 运动员需要触碰队伍标记，然后往回跑。

def onHear(event):
    referee = pet.findNearestByType("wizard")
    # 如果说话的人是裁判员referee并且说的是"Start"：
    if event.speaker == referee and event.message == "Start":
        # 让宠物跑到红色标记。
        pet.moveXY(53, 27)
        # 然后跑回来。
        pet.moveXY(6, 27)

# 指派onHear函数来处理"hear"事件。
pet.on("hear", onHear)

```



